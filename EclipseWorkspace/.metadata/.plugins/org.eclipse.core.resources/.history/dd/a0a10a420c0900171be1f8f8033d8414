import javax.xml.soap.Node;

public class DLinkedPriorityQueue<T> implements PriorityQueueADT<T> 
{
    /** Attribute:
     * Head of the queue
    **/
    private DPriorityNode<T> front;
    
    /** Attribute:
     * rear of the queue
    **/
    private DPriorityNode<T> rear;
    
    /** Attribute:
     * count of how many nodes
    **/
    private int count;
    
    
    /**
     * 1st overload of the constructor (Creates an empty priority queue, with null data and zero priority.)
     **/
    public DLinkedPriorityQueue()
    {
	front = null;
	rear = null;
	count = 0;
	
    }
    
       	/**
	* Add element
	* @param T element
	**/
	public void add(T element, double priority)    ///smallest value have the highest priority
	{
	    DPriorityNode<T> node =  new DPriorityNode<T>(element, priority); 
	    
	    if(isEmpty())
	    {
		front = node;
		rear = node;
	    }
	    else
	    {
		if(rear.getPriority()>priority) //if priority of my node is smaller than rear; put at the the end 
		rear.setPrev(node);
		else if(rear.getPriority()<priority)
		{
		    DPriorityNode<T> it = rear.getNext(); //iterator
		    while(it.getPriority()<priority && it.getNext()!= null)
		    {
			it = it.getNext(); //iterate until suitable position if found
		    }
		    
		    if(it.getNext()== null)//new node is the highest priority
		    {
			it.setNext(node);
		    }
		    else//place in correct position
		    {
			//saves pointer of curr node
			DPriorityNode<T> tmp_nxt = it.getNext();
			node.setNext(tmp_nxt);
			it.setNext(node);
						
		    }
		    
		    
		}
	    }
	    
	    count++; //increment count
	}

	/**
	* Removes and returns the data item in the priority queue with smallest priority
	* @throws EmptyPriorityQueueException
	* @return T contained_element
	**/
	public T removeMin() throws EmptyPriorityQueueException 
	{
	    if(count == 0)
		throw new EmptyPriorityQueueException ("Empty Queue"); //throws error if empty
	    
	    T contained_element = front.getElement();
	     front = front.prev();
	     
	     
	     count--; //decrement count
	     return contained_element;
	}

	/**
	* Update the element priority in the queue
	* @param T element
	* @param double priority
	* @throws InvalidElementException 
	**/
	public void updatePriority(T element, double newPriority) throws InvalidElementException 
	{
	    if(isEmpty()) //if the queue is empty, then element is not in the queue
	    throw new InvalidElementException("Element not in the queue");
	    
	    
	    DPriorityNode<T> node;
	    DPriorityNode<T> it;
	    DPriorityNode<T> tmp_nxt;
	    DPriorityNode<T> tmp_prv;
	    
	    
	  ///////////////////////////////Find desired node and change priority
	    if(front.getElement().equals(element))
	    {
		node = front;
		node.setPriority(newPriority);
		
		return;//end method
	    }
	    else
	    {
		 it = rear; //set iterator as the rear
		 while(true) //iterate through the queue
	    {
	       if(it.getElement().equals(element))
	       {
		 node =  it; //saves a copy
		 node.setPriority(newPriority);  
		 
		 //remove node from curr position by removing link in the queue
		 tmp_nxt = node.getNext();
		 tmp_prv = node.getPrev();
		 tmp_prv.setNext(tmp_nxt);
		 
		      break; //if element is found: break out of infinite loop
	       }
		
	       	       //////
	       if(it.getNext() == null) //end is reached without finding the element
	       	   throw new InvalidElementException("Element not in the queue");
	      	       //////
		it = it.getNext();//iterate through the queue
		       
	    }
	    }    
	     
	    	///add node with correct priority///////////////////////////////////////////////
	    	if(rear.getPriority()> newPriority) //if priority of my node is smaller than rear; put at the the end 
		rear.setPrev(node);
		else if(rear.getPriority()<newPriority)
		{
		    it = rear.getNext(); //iterator
		    while(it.getPriority()<newPriority && it.getNext()!= null)
		    {
			it = it.getNext(); //iterate until suitable position if found
		    }
		    
		    if(it.getNext()== null)//new node is the highest priority
		    {
			it.setNext(node);
		    }
		    else//place in correct position
		    {
			//saves pointer of curr node
			tmp_nxt = it.getNext();
			node.setNext(tmp_nxt);
			it.setNext(node);
						
		    }
		    
		    
		
	    }    
	    
	 }

	/**
	* Check if the queue is empty
	* @return boolean isEmpty
	**/
	public boolean isEmpty() 
	{
	    return (count == 0);
	}

	
	/**
	* Check size
	* @return int size
	**/
	public int size() 
	{
	    return count;
	}
	
	
	/**
	* Give a string representation of the queue (from head to rear)
	* @return String s
	**/
	public String toString() 
	{
	   String s = "";
	    
	   DPriorityNode<T> it = front;
	   while(it.getPrev()!= null)
	   {
	       s += it.toString()+", " ;
	       
	       it = it.getPrev();//iterate through the queue
	       
	   }
	    
	    	    
	    return s;
	}
	
	
	
	    

	

}
