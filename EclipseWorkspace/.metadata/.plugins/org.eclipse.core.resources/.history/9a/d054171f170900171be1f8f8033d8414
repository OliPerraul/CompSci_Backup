import javax.xml.soap.Node;

public class DLinkedPriorityQueue<T> implements PriorityQueueADT<T> 
{
    /** Attribute:
     * Head of the queue
    **/
    private DPriorityNode<T> front;
    
    /** Attribute:
     * rear of the queue
    **/
    private DPriorityNode<T> rear;
    
    /** Attribute:
     * count of how many nodes
    **/
    private int count;
    
    
    /**
     * 1st overload of the constructor (Creates an empty priority queue, with null data and zero priority.)
     **/
    public DLinkedPriorityQueue()
    {
	front = null;
	rear = null;
	count = 0;
	
    }
    
       	/**
	* Add element
	* @param T element
	**/
	public void add(T element, double priority)    ///smallest value have the highest priority
	{
	    
	    DPriorityNode<T> node =  new DPriorityNode<T>(element, priority); 
	  //temporary pointers
	    DPriorityNode<T> tmp_nxt;
	    DPriorityNode<T> tmp_prv;
	    
	    if(isEmpty())
	    {
		front = node;
		rear = node;
		
		//set pointers to itself
		node.setNext(node); 
		node.setPrev(node);
	    }
	    else
	    {
		if(priority<front.getPriority()) //if priority of my node is smaller: add at the front
		{
		  //adjust pointers
		    node.setNext(rear);
		    node.setPrev(front);
		    
		    //place node in the list
		    front.setNext(node);
		}
		else if(priority>front.getPriority())
		{
		    DPriorityNode<T> it = front.getPrev(); //iterator
		    while(priority>it.getPriority() && !it.getPrev().equals(front)) //while priority of node is greater & end is not reached
		    {
			it = it.getPrev(); //iterate until suitable position if found
		    }
		    
		      	//suitable position is found  (either the end or the pos where the iterator stopped)
		    	//adjust pointers
			node.setNext(it);
			node.setPrev(it.getPrev());
			
			//insert node
			it.setPrev(node);
					    
		}
	    }
	    
	    count++; //increment count
	}

	/**
	* Removes and returns the data item in the priority queue with smallest priority
	* @throws EmptyPriorityQueueException
	* @return T contained_element
	**/
	public T removeMin() throws EmptyPriorityQueueException 
	{
	    if(count == 0)
		throw new EmptyPriorityQueueException ("Empty Queue"); //throws error if empty
	    
	    T contained_element = front.getElement();
	     front = front.getPrev();
	     
	     
	     count--; //decrement count
	     return contained_element;
	}

	/**
	* Update the element priority in the queue
	* @param T element
	* @param double priority
	* @throws InvalidElementException 
	**/
	public void updatePriority(T element, double newPriority) throws InvalidElementException 
	{
	    if(isEmpty()) //if the queue is empty, then element is not in the queue
	    throw new InvalidElementException("Element not in the queue");
	    
	    
	    DPriorityNode<T> node;
	    DPriorityNode<T> it;
	    DPriorityNode<T> tmp_link; //tmp link used to adjust pointers
	
	    
	  ///////////////////////////////1. Find desired node and change priority
	    if(front.getElement().equals(element)) //if front of the list is the one we're looking for
	    {
		 node = front; //saves a copy
		 
		 tmp_link = front.getPrev();//save link to previous node to assign as new front
		 
		 //remove node from curr position by removing link in the queue
		 front.setPrev(front.getNext());
		 front = tmp_link;//assign link
	    }
	    else
	    {
	    it = front; //set iterator as the rear
	    while(true) //iterate through the queue
	    {
	       if(it.getElement().equals(element))
	       {
		 node =  it; //saves a copy
		 node.setPriority(newPriority);  
		 
		 //remove node from curr position by removing link in the queue
		 it.setPrev(it.getNext());
		 break; //if element is found: break out of infinite loop
	       }
		
	       	       //////
	       if(it.getNext() == null) //end is reached without finding the element
	       	   throw new InvalidElementException("Element not in the queue");
	      	       //////
		it = it.getNext();//iterate through the queue
		       
	    }
	    }    
	    //////////////////////////////.2  Adjust priority
	    
	    node.setPriority(newPriority);
	    
	    
	    
	    ////////////////////////////////3. add node with correct priority
	    	if(newPriority<front.getPriority()) //if priority of my node is smaller: add at the front
		{
		  //adjust pointers
		    node.setNext(rear);
		    node.setPrev(front);
		    
		    //place node in the list
		    front.setNext(node);
		}
		else if(newPriority>front.getPriority())
		{
		    it = front.getPrev(); //iterator
		    while(newPriority>it.getPriority() && !it.getPrev().equals(front)) //while priority of node is greater & end is not reached
		    {
			it = it.getPrev(); //iterate until suitable position if found
		    }
		    
		      	//suitable position is found  (either the end or the pos where the iterator stopped)
		    	//adjust pointers
			node.setNext(it);
			node.setPrev(it.getPrev());
			
			//insert node
			it.setPrev(node);
					    
		}
	    
	 }

	/**
	* Check if the queue is empty
	* @return boolean isEmpty
	**/
	public boolean isEmpty() 
	{
	    return (count == 0);
	}

	
	/**
	* Check size
	* @return int size
	**/
	public int size() 
	{
	    return count;
	}
	
	
	/**
	* Give a string representation of the queue (from head to rear)
	* @return String s
	**/
	public String toString() 
	{
	   String s = "";
	    
	   DPriorityNode<T> it = front;
	   while(it.getPrev()!= null)
	   {
	       s += it.toString()+", " ;
	       
	       it = it.getPrev();//iterate through the queue
	       
	   }
	    
	    	    
	    return s;
	}
	
	
	
	    

	

}
